#!/usr/bin/env zsh
# Sourced by zsh for every interactive zsh shell after .zprofile

# UNCOMMENT TO PROFILE ZSH STARTUP TIME
# zmodload zsh/zprof
# Also see https://github.com/romkatv/zsh-bench for benchmarking

# all zsh files
typeset -U config_files
config_files=(~/.config/zsh/**/*.zsh)

################################################################################
# PHASE 1: path.zsh files
################################################################################

# load brew path first, since others may depend on it
if [[ -f ~/.config/zsh/brew.path.zsh ]]; then
  source ~/.config/zsh/brew.path.zsh
fi

# load the path files
for file in ${(M)config_files:#*/path.zsh}; do
  source "$file"
done

################################################################################
# PHASE 2: *.zsh files (except completion.zsh)
################################################################################

# load everything but the path and completion files
for file in ${${config_files:#*/path.zsh}:#*/completion.zsh}; do
  source "$file"
done

################################################################################
# PHASE 3: Zsh plugins (compile helper + update notification)
################################################################################

# Zsh "plugin manager" - compile to wordcode for faster loading
function zcompile-many() {
  local f
  for f; do zcompile -R -- "$f".zwc "$f"; done
}

# Plugins are installed by run_once_after_bootstrap-zsh-plugins.sh during initial setup
# If plugins don't exist, shell works without them (just without those features)

# Check for background update notification from previous session
if [[ -f "$HOME/.zsh-plugins-updated" ]]; then
  echo "âœ¨ Zsh plugins were updated in the background ($(cat "$HOME/.zsh-plugins-updated"))"
  rm -f "$HOME/.zsh-plugins-updated"
fi

################################################################################
# PHASE 4: Enable zsh completion
################################################################################

# Enable the "new" completion system (compsys).
autoload -Uz compinit && compinit
[[ ~/.zcompdump.zwc -nt ~/.zcompdump ]] || zcompile-many ~/.zcompdump

ZSH_AUTOSUGGEST_MANUAL_REBIND=1

################################################################################
# PHASE 5: Zsh plugins (load with graceful degradation)
################################################################################

# Load plugins if they exist, skip gracefully if missing
if [[ -f ~/zsh-plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then
  source ~/zsh-plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi

if [[ -f ~/zsh-plugins/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
  source ~/zsh-plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
fi

if [[ -f ~/zsh-plugins/zsh-history-substring-search/zsh-history-substring-search.zsh ]]; then
  source ~/zsh-plugins/zsh-history-substring-search/zsh-history-substring-search.zsh
fi

if [[ -f ~/zsh-plugins/zsh-z/zsh-z.plugin.zsh ]]; then
  source ~/zsh-plugins/zsh-z/zsh-z.plugin.zsh
fi

################################################################################
# PHASE 6: completion.zsh files
################################################################################

# load every completion after autocomplete loads
for file in ${(M)config_files:#*/completion.zsh}; do
  source "$file"
done

unset config_files

# ==============================================================================
# History
# ==============================================================================
HISTSIZE=5000               #How many lines of history to keep in memory
HISTFILE=~/.zsh_history     #Where to save history to disk
SAVEHIST=5000               #Number of history entries to save to disk
HISTDUP=erase               #Erase duplicates in the history file
setopt    appendhistory     #Append history to the history file (no overwriting)
setopt    sharehistory      #Share history across terminals
setopt    incappendhistory  #Immediately append to the history file, not just when a term is killed
setopt    histignorespace   #Don't add commands that start with space to history

# ==============================================================================
# Misc options
# ==============================================================================
unsetopt correct # disable zsh autocorrect
export CASE_SENSITIVE="true" # case-sensitive completion
export DISABLE_AUTO_TITLE="true"
export DISABLE_LS_COLORS="true"
export HISTORY_SUBSTRING_SEARCH_ENSURE_UNIQUE="true" # zsh-history-substring-search

# ==============================================================================
# Keybinds
# ==============================================================================
# Use vim cli mode
bindkey -v

# Iterate through command history
bindkey '^P' up-history
bindkey '^N' down-history

# backspace and ^h working even after
# returning from command mode
bindkey '^?' backward-delete-char
bindkey '^h' backward-delete-char

# ctrl-w removed word backwards
bindkey '^w' backward-kill-word

# ctrl-r starts searching history backward
bindkey '^r' history-incremental-search-backward
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down

################################################################################
# PHASE 7: Zsh plugin updates (async, non-blocking)
################################################################################

# Manual update function: run `update-zsh-plugins` to update all plugins
function update-zsh-plugins() {
  local plugin_dir="$HOME/zsh-plugins"

  echo "ðŸ”„ Updating zsh plugins..."

  for dir in "$plugin_dir"/*(/N); do
    local name="${dir:t}"
    if [[ -d "$dir/.git" ]]; then
      echo "  ðŸ“¦ Updating $name..."
      # For shallow clones, fetch and reset is more reliable than pull --rebase
      if git -C "$dir" fetch --depth=1 origin 2>/dev/null; then
        local branch=$(git -C "$dir" symbolic-ref --short HEAD 2>/dev/null || echo "master")
        if git -C "$dir" reset --hard "origin/$branch" 2>/dev/null; then
          echo "  âœ… $name updated"
        else
          echo "  âš ï¸  $name reset failed"
        fi
      else
        echo "  âš ï¸  $name fetch failed (network issue?)"
      fi
    fi
  done

  # Recompile plugins after update
  echo "âš¡ Recompiling plugins..."
  [[ -d ~/zsh-plugins/zsh-syntax-highlighting ]] && zcompile-many ~/zsh-plugins/zsh-syntax-highlighting/{zsh-syntax-highlighting.zsh,highlighters/*/*.zsh} 2>/dev/null
  [[ -d ~/zsh-plugins/zsh-autosuggestions ]] && zcompile-many ~/zsh-plugins/zsh-autosuggestions/{zsh-autosuggestions.zsh,src/**/*.zsh} 2>/dev/null
  [[ -d ~/zsh-plugins/zsh-history-substring-search ]] && zcompile-many ~/zsh-plugins/zsh-history-substring-search/zsh-history-substring-search.zsh 2>/dev/null
  [[ -d ~/zsh-plugins/zsh-z ]] && zcompile-many ~/zsh-plugins/zsh-z/zsh-z.plugin.zsh 2>/dev/null

  # Update last update timestamp
  date +%s > "$HOME/.zsh-plugins-last-update"
  echo "âœ… Plugin update complete"
}

# Background update function (runs async after shell loads)
function _zsh_plugins_background_update() {
  local last_update_file="$HOME/.zsh-plugins-last-update"
  local update_interval=86400  # 24 hours in seconds
  local current_time=$(date +%s)
  local last_update=0

  # Check if we should update (based on last update time)
  if [[ -f "$last_update_file" ]]; then
    last_update=$(cat "$last_update_file" 2>/dev/null || echo 0)
  fi

  local time_since_update=$((current_time - last_update))
  if (( time_since_update < update_interval )); then
    return 0  # Too soon, skip update
  fi

  # Quick network connectivity check (1 second timeout)
  local timeout_cmd=""
  if command -v gtimeout &> /dev/null; then
    timeout_cmd="gtimeout 1"
  elif command -v timeout &> /dev/null; then
    timeout_cmd="timeout 1"
  fi

  if [[ -n "$timeout_cmd" ]]; then
    if ! $timeout_cmd curl -sf --max-time 1 https://github.com > /dev/null 2>&1; then
      return 0  # Network not responsive, skip update
    fi
  fi

  # Run update in background (silently)
  (
    local plugin_dir="$HOME/zsh-plugins"
    local updated_plugins=()

    for dir in "$plugin_dir"/*(/N); do
      if [[ -d "$dir/.git" ]]; then
        local name="${dir:t}"
        local before_hash=$(git -C "$dir" rev-parse HEAD 2>/dev/null)
        # For shallow clones, fetch and reset is more reliable than pull --rebase
        if git -C "$dir" fetch --depth=1 origin 2>/dev/null; then
          local branch=$(git -C "$dir" symbolic-ref --short HEAD 2>/dev/null || echo "master")
          git -C "$dir" reset --hard "origin/$branch" 2>/dev/null || true
        fi
        local after_hash=$(git -C "$dir" rev-parse HEAD 2>/dev/null)
        # Track if plugin was actually updated
        if [[ "$before_hash" != "$after_hash" ]]; then
          updated_plugins+=("$name")
        fi
      fi
    done

    # Update timestamp after successful update
    date +%s > "$last_update_file"

    # Write notification file if any plugins were updated
    if (( ${#updated_plugins[@]} > 0 )); then
      echo "${(j:, :)updated_plugins}" > "$HOME/.zsh-plugins-updated"
    fi
  ) &>/dev/null &
  disown
}

# Trigger background update after shell loads (async, non-blocking)
# Only if plugins directory exists
if [[ -d "$HOME/zsh-plugins" ]]; then
  _zsh_plugins_background_update
fi

# Clean up - undefine the zcompile-many function (we're done with it)
unfunction zcompile-many

# UNCOMMENT TO PROFILE ZSH STARTUP TIME
# zprof

################################################################################
# PHASE 8: Tool integrations
################################################################################

if command -v wt >/dev/null 2>&1; then eval "$(command wt config shell init zsh)"; fi
if command -v zoxide >/dev/null 2>&1; then eval "$(zoxide init zsh)"; fi
[[ -s "$HOME/.bun/_bun" ]] && source "$HOME/.bun/_bun"

################################################################################
# PHASE 9: Prompt
################################################################################

eval "$(starship init zsh)"
